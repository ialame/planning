\documentclass[11pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}
\usepackage[shortcuts]{extdash}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{tcolorbox}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{amssymb} % For \checkmark
\usepackage{amsmath} % For \text in math mode

% Page geometry
\geometry{margin=2.5cm,headheight=14pt}

% Allow line breaks in paths
\usepackage{url}
\usepackage{breakurl}

% Colors
\definecolor{codebackground}{RGB}{245,245,245}
\definecolor{codecomment}{RGB}{0,128,0}
\definecolor{codestring}{RGB}{163,21,21}
\definecolor{codekeyword}{RGB}{0,0,255}
\definecolor{infobox}{RGB}{230,242,255}
\definecolor{warningbox}{RGB}{255,243,224}
\definecolor{successbox}{RGB}{230,255,237}

% Code listing style
\lstdefinestyle{javastyle}{
    backgroundcolor=\color{codebackground},
    commentstyle=\color{codecomment},
    keywordstyle=\color{codekeyword},
    stringstyle=\color{codestring},
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray},
    showstringspaces=false,
    tabsize=2
}

\lstdefinestyle{jsstyle}{
    backgroundcolor=\color{codebackground},
    commentstyle=\color{codecomment},
    keywordstyle=\color{codekeyword},
    stringstyle=\color{codestring},
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray},
    showstringspaces=false,
    tabsize=2,
    keywords={const, let, var, async, await, function, if, else, try, catch, finally, return, fetch, console, log, error}
}

\lstdefinestyle{sqlstyle}{
    language=SQL,
    backgroundcolor=\color{codebackground},
    commentstyle=\color{codecomment},
    keywordstyle=\color{codekeyword}\bfseries,
    stringstyle=\color{codestring},
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    frame=single,
    showstringspaces=false,
    tabsize=2,
    morekeywords={SELECT, FROM, WHERE, ORDER, BY, INSERT, INTO, VALUES}
}

\lstdefinestyle{jsonStyle}{
    basicstyle=\ttfamily\footnotesize,
    backgroundcolor=\color{codebackground},
    frame=single,
    breaklines=true,
    showstringspaces=false,
    tabsize=2
}

% Headers and footers
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Guide d'Intégration - Planification par Rôles}
\fancyhead[R]{\thepage}
\fancyfoot[C]{Système de Gestion des Commandes Pokémon}

% Title
\title{\textbf{\Huge Guide d'Intégration} \\ \vspace{0.5cm} \LARGE Planification Améliorée par Rôles}
\author{Système de Gestion des Commandes Pokémon}
\date{\today}

\begin{document}

    \maketitle
    \tableofcontents
    \newpage

    \section{Vue d'ensemble}

    Le nouveau système de planification améliore l'algorithme existant en apportant les fonctionnalités suivantes :

    \begin{tcolorbox}[colback=successbox,colframe=green!50!black,title=\textbf{Améliorations Principales}]
        \begin{itemize}[leftmargin=*]
            \item \textbf{Suppression du filtre de date initiale} : Traite TOUTES les commandes en attente
            \item \textbf{Assignment par rôle} : \texttt{ROLE\_NOTEUR} pour \texttt{A\_NOTER}, \texttt{ROLE\_CERTIFICATEUR} pour \texttt{A\_CERTIFIER}
            \item \textbf{Optimisation de la charge} : Trouve l'employé le moins chargé dans chaque rôle
            \item \textbf{Respect des heures de travail} : Planifie dans les heures ouvrables (9h-18h)
        \end{itemize}
    \end{tcolorbox}

    \subsection{Architecture du Système}

    Le nouveau système introduit le service \texttt{ImprovedPlanningService} qui travaille en conjonction avec le contrôleur existant pour fournir une planification basée sur les rôles des employés.

    \section{Étape 1 : Ajouter le Nouveau Service}

    \subsection{Création du Fichier}

    \textbf{Emplacement :}

    \noindent\texttt{\small src/main/java/com/pcagrade/order/service/\\ImprovedPlanningService.java}

    \subsection{Structure du Service}

    Le service \texttt{ImprovedPlanningService} contient les méthodes principales suivantes :

    \begin{lstlisting}[style=javastyle,language=Java,caption={Methodes principales du service},literate={é}{{\'e}}1{è}{{\`e}}1{à}{{\`a}}1{ô}{{\^o}}1{û}{{\^u}}1]
// Methode principale d'execution
public Map<String, Object> executeRoleBasedPlanning(
    LocalDate planningDate,
    boolean cleanFirst
)

// Recupere les commandes par status (sans filtre de date)
private List<Map<String, Object>> getOrdersByStatus(int status)

// Recupere les employes ayant un role specifique
private List<Map<String, Object>> getEmployeesByRole(String roleName)

// Assigne les commandes en trouvant l'employe le moins charge
private int assignOrdersToEmployees(...)
    \end{lstlisting}

    \subsection{Constantes du Service}

    \begin{lstlisting}[style=javastyle,language=Java]
private static final int TIME_PER_CARD_MINUTES = 3;
private static final LocalTime WORK_START_TIME = LocalTime.of(9, 0);
private static final LocalTime WORK_END_TIME = LocalTime.of(18, 0);

// Order Status Constants
private static final int STATUS_A_NOTER = 2;      // To be evaluated
private static final int STATUS_A_CERTIFIER = 3;  // To be encapsulated
    \end{lstlisting}

    \section{Étape 2 : Modifier le Contrôleur}

    \subsection{Injection du Service}

    Dans \texttt{PlanningController.java}, ajoutez l'injection du nouveau service :

    \begin{lstlisting}[style=javastyle,language=Java,literate={é}{{\'e}}1]
@Autowired
private ImprovedPlanningService improvedPlanningService;
    \end{lstlisting}

    \subsection{Ajout de l'Endpoint}

    Ajoutez la méthode suivante à \texttt{PlanningController.java} :

    \begin{lstlisting}[style=javastyle,language=Java,caption={Endpoint de planification basee sur les roles},literate={é}{{\'e}}1{è}{{\`e}}1{à}{{\`a}}1]
@PostMapping("/generate-role-based")
@Transactional
public ResponseEntity<Map<String, Object>> generateRoleBasedPlanning(
        @RequestBody Map<String, Object> request) {

    Map<String, Object> result = new HashMap<>();

    try {
        String planningDateStr = (String) request.getOrDefault(
            "planningDate",
            LocalDate.now().toString()
        );
        boolean cleanFirst = (Boolean) request.getOrDefault(
            "cleanFirst",
            true
        );

        LocalDate planningDate = LocalDate.parse(planningDateStr);

        log.info("Generating role-based planning for date: {}",
                planningDate);

        result = improvedPlanningService.executeRoleBasedPlanning(
            planningDate,
            cleanFirst
        );

        if ((Boolean) result.get("success")) {
            return ResponseEntity.ok(result);
        } else {
            return ResponseEntity.status(500).body(result);
        }

    } catch (Exception e) {
        log.error("Error in role-based planning generation", e);
        result.put("success", false);
        result.put("message", "Planning failed: " + e.getMessage());
        return ResponseEntity.internalServerError().body(result);
    }
}
    \end{lstlisting}

    \textbf{Endpoint cree :}
    \begin{center}
        \texttt{POST /api/planning/generate-role-based}
    \end{center}

    \section{Étape 3 : Test du Système}

    \subsection{Test avec cURL}

    \begin{lstlisting}[style=javastyle,language=bash]
curl -X POST http://localhost:8080/api/planning/generate-role-based \
  -H "Content-Type: application/json" \
  -d '{
    "planningDate": "2025-06-01",
    "cleanFirst": true
  }'
    \end{lstlisting}

    \subsection{Réponse Attendue}

    \begin{lstlisting}[style=jsonStyle,caption={Exemple de reponse JSON},literate={é}{{\'e}}1]
{
  "success": true,
  "message": "Planning completed: 25 orders assigned",
  "planningDate": "2025-06-01",
  "totalOrdersAssigned": 25,
  "ordersToNote": 15,
  "ordersToCertify": 10,
  "noteursUsed": 3,
  "certificateursUsed": 2,
  "totalCards": 450,
  "totalMinutes": 1350,
  "totalHours": "22.5",
  "algorithm": "ROLE_BASED_GREEDY",
  "noteurWorkloads": [
    {
      "employeeId": "abc123...",
      "employeeName": "John Doe",
      "totalMinutes": 480,
      "totalHours": "8.0",
      "workloadPercentage": 100,
      "status": "busy"
    }
  ],
  "certificateurWorkloads": [...]
}
    \end{lstlisting}

    \section{Comparaison Ancien vs Nouveau}

    \begin{table}[h]
        \centering
        \small
        \begin{tabular}{|p{6.5cm}|p{6.5cm}|}
            \hline
            \textbf{Ancien Système (Round-Robin)} & \textbf{Nouveau Système (Role-Based)} \\
            \hline
            $\times$ Filtre de date requis (startDate) & \checkmark~Traite toutes les commandes en attente \\
            \hline
            $\times$ Pas de distinction de rôles & \checkmark~Assigne selon le rôle requis \\
            \hline
            $\times$ Distribution simple en alternance & \checkmark~Trouve l'employé le moins chargé \\
            \hline
            $\times$ Pas d'optimisation de charge & \checkmark~Optimise la charge de travail \\
            \hline
            \multicolumn{2}{|c|}{\textbf{Résultat}} \\
            \hline
            Employés mal utilisés, certains surchargés & Meilleure distribution, respect des compétences \\
            \hline
        \end{tabular}
        \caption{Comparaison des deux systèmes}
    \end{table}

    \section{Fonctionnement Détaillé}

    \subsection{Récupération des Commandes par Status}

    Le système récupère les commandes en fonction de leur status, en les triant par priorité :

    \begin{lstlisting}[style=sqlstyle,caption={Requete SQL de recuperation des commandes},literate={é}{{\'e}}1{è}{{\`e}}1]
SELECT
    HEX(o.id) as id,
    o.num_commande as orderNumber,
    o.delai as priority,
    o.status,
    COALESCE(
        (SELECT COUNT(*) FROM card_certification_order cco
         WHERE cco.order_id = o.id),
        10
    ) as cardCount
FROM `order` o
WHERE o.status = ? -- 2 pour A_NOTER, 3 pour A_CERTIFIER
  AND o.annulee = 0
  AND o.paused = 0
ORDER BY
    CASE o.delai
        WHEN 'X' THEN 1    -- Excelsior en premier
        WHEN 'F+' THEN 2   -- Fast+ ensuite
        WHEN 'F' THEN 3    -- Fast
        WHEN 'C' THEN 4    -- Classic
        WHEN 'E' THEN 5    -- Economy
        ELSE 6
    END ASC,
    o.date ASC
    \end{lstlisting}

    \subsection{Récupération des Employés par Rôle}

    Les employés sont récupérés en fonction de leur appartenance aux groupes de rôles :

    \begin{lstlisting}[style=sqlstyle,caption={Requete SQL de recuperation des employes},literate={é}{{\'e}}1{è}{{\`e}}1]
SELECT DISTINCT
    HEX(e.id) as id,
    e.first_name as firstName,
    e.last_name as lastName,
    e.email,
    e.work_hours_per_day as workHoursPerDay,
    e.active
FROM j_employee e
INNER JOIN j_employee_group eg ON e.id = eg.employee_id
INNER JOIN j_group g ON eg.group_id = g.id
WHERE g.name = ? -- 'ROLE_NOTEUR' ou 'ROLE_CERTIFICATEUR'
  AND e.active = 1
  AND g.active = 1
ORDER BY e.last_name, e.first_name
    \end{lstlisting}

    \subsection{Algorithme d'Assignment}

    \begin{tcolorbox}[colback=infobox,colframe=blue!50!black,title=\textbf{Algorithme d'Assignment Intelligent}]
        \textbf{Pour chaque commande :}
        \begin{enumerate}
            \item \textbf{Trouve l'employé le moins chargé} dans le rôle approprié
            \item \textbf{Calcule la durée} : $\text{cardCount} \times 3 \text{ minutes}$
            \item \textbf{Détermine l'heure de début} :
            \begin{itemize}
                \item Si l'employé n'a pas de tâches : 9h00
                \item Sinon : Après la dernière tâche + 15min de pause
            \end{itemize}
            \item \textbf{Sauvegarde en base} dans \texttt{j\_planning}
            \item \textbf{Met à jour la charge} de l'employé
        \end{enumerate}
    \end{tcolorbox}

    \section{Configuration des Rôles}

    \subsection{Vérification des Rôles Existants}

    \begin{lstlisting}[style=sqlstyle]
SELECT name, description, permission_level
FROM j_group
WHERE name IN ('ROLE_NOTEUR', 'ROLE_CERTIFICATEUR');
    \end{lstlisting}

    \subsection{Assigner un Rôle à un Employé}

    \textbf{Étape 1 :} Vérifier l'ID du groupe

    \begin{lstlisting}[style=sqlstyle]
SELECT HEX(id) as group_id, name
FROM j_group
WHERE name = 'ROLE_NOTEUR';
    \end{lstlisting}

    \textbf{Étape 2 :} Assigner l'employé au groupe

    \begin{lstlisting}[style=sqlstyle]
INSERT INTO j_employee_group (employee_id, group_id)
VALUES (
  UNHEX('employee_id_here'),
  UNHEX('group_id_here')
);
    \end{lstlisting}

    \subsection{Via l'Interface Web}

    \begin{enumerate}
        \item Allez dans \textbf{Groups}
        \item Sélectionnez \texttt{ROLE\_NOTEUR} ou \texttt{ROLE\_CERTIFICATEUR}
        \item Cliquez sur \textbf{Assign Employees}
        \item Ajoutez les employés souhaités
    \end{enumerate}

    \section{Métriques et Monitoring}

    Le système retourne des statistiques détaillées dans la réponse JSON :

    \subsection{Métriques par Type de Commande}

    \begin{itemize}
        \item \texttt{ordersToNote} : Nombre de commandes A\_NOTER
        \item \texttt{ordersToCertify} : Nombre de commandes A\_CERTIFIER
    \end{itemize}

    \subsection{Métriques par Rôle}

    \begin{itemize}
        \item \texttt{noteursUsed} : Nombre de noteurs utilisés
        \item \texttt{certificateursUsed} : Nombre de certificateurs utilisés
    \end{itemize}

    \subsection{Métriques par Employé}

    Dans les objets \texttt{noteurWorkloads} et \texttt{certificateurWorkloads} :

    \begin{itemize}
        \item \texttt{totalMinutes} : Temps total assigné
        \item \texttt{workloadPercentage} : Pourcentage de la capacité (0-100\%+)
        \item \texttt{status} :
        \begin{itemize}
            \item \texttt{"available"} : < 80\%
            \item \texttt{"busy"} : 80-99\%
            \item \texttt{"overloaded"} : $\geq$ 100\%
        \end{itemize}
    \end{itemize}

    \section{Utilisation depuis le Frontend}

    \subsection{Appel depuis Vue.js/TypeScript}

    \begin{lstlisting}[style=jsstyle,caption={Exemple d'appel depuis Vue.js},literate={é}{{\'e}}1{è}{{\`e}}1]
const generateRoleBasedPlanning = async () => {
  try {
    const response = await fetch(
      `${API_BASE_URL}/api/planning/generate-role-based`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          planningDate: '2025-06-01',
          cleanFirst: true
        })
      }
    );

    const result = await response.json();

    if (result.success) {
      console.log('Planning generated:', result.message);
      console.log('Orders assigned:', result.totalOrdersAssigned);
      console.log('Noteurs:', result.noteurWorkloads);
      console.log('Certificateurs:', result.certificateurWorkloads);
    } else {
      console.error('Planning failed:', result.message);
    }
  } catch (error) {
    console.error('Error:', error);
  }
}
    \end{lstlisting}

    \section{Points Importants}

    \subsection{Validation des Rôles}

    \begin{tcolorbox}[colback=warningbox,colframe=orange!75!black,title=\textbf{Attention}]
        Le système échoue si :
        \begin{itemize}
            \item Il y a des commandes A\_NOTER mais aucun ROLE\_NOTEUR
            \item Il y a des commandes A\_CERTIFIER mais aucun ROLE\_CERTIFICATEUR
        \end{itemize}

        \textbf{Solution :} Assignez au moins un employé à chaque rôle nécessaire.
    \end{tcolorbox}

    \subsection{Surcharge des Employés}

    Si un employé dépasse 100\% de sa capacité :
    \begin{itemize}
        \item Le système continue à lui assigner des tâches
        \item Son status devient \texttt{"overloaded"}
        \item Visible dans les workload summaries
    \end{itemize}

    \textbf{Solution :} Ajoutez plus d'employés ou réduisez le \texttt{workHoursPerDay}.

    \subsection{Nettoyage des Plannings}

    \begin{tcolorbox}[colback=warningbox,colframe=orange!75!black,title=\textbf{Attention}]
        \texttt{cleanFirst: true} supprime \textbf{tous} les plannings de la date spécifiée avant d'en créer de nouveaux.

        \textbf{Attention :} Les plannings déjà commencés seront également supprimés.
    \end{tcolorbox}

    \section{Migration depuis l'Ancien Système}

    \subsection{Option 1 : Remplacement Complet}

    Dans votre frontend, remplacez l'appel à :

    \begin{lstlisting}[style=jsstyle,literate={é}{{\'e}}1]
// ANCIEN
POST /api/planning/generate-unified

// PAR
POST /api/planning/generate-role-based
    \end{lstlisting}

    \subsection{Option 2 : Coexistence}

    Gardez les deux endpoints et laissez l'utilisateur choisir :

    \begin{lstlisting}[style=jsstyle,literate={é}{{\'e}}1]
if (useRoleBasedPlanning) {
  await generateRoleBasedPlanning();
} else {
  await generateUnifiedPlanning();
}
    \end{lstlisting}

    \section{Améliorations Futures}

    \begin{enumerate}
        \item \textbf{Support de plus de status} : A\_SCANNER, A\_PREPARER, etc.
        \item \textbf{Compétences avancées} : Efficiency rating par employé
        \item \textbf{Contraintes horaires} : Pauses obligatoires, jours fériés
        \item \textbf{Optimisation multi-critères} : Priorité + charge + compétences
        \item \textbf{Prévisualisation} : Voir le planning avant de le sauvegarder
    \end{enumerate}

    \section{FAQ}

    \subsection{Que se passe-t-il si un employé a plusieurs rôles ?}

    Il sera utilisé pour tous les types de commandes correspondant à ses rôles.

    \subsection{Comment gérer les commandes urgentes (X, F+) ?}

    Le système les traite déjà en priorité grâce au \texttt{ORDER BY} dans la requête SQL.

    \subsection{Peut-on limiter le nombre de commandes par employé ?}

    Actuellement non, mais c'est une amélioration future possible.

    \subsection{Comment voir la répartition avant de valider ?}

    Ajoutez un paramètre \texttt{preview: true} qui retourne le résultat sans sauvegarder (à implémenter).

    \section{Support et Dépannage}

    Pour toute question ou problème :

    \begin{enumerate}
        \item \textbf{Vérifiez les logs :} \texttt{tail -f logs/application.log}
        \item \textbf{Vérifiez les rôles :} \texttt{SELECT * FROM j\_group}
        \item \textbf{Vérifiez les assignations :} \texttt{SELECT * FROM j\_employee\_group}
    \end{enumerate}

    \vspace{1cm}

    \begin{center}
        \Large\textbf{Bonne planification !}
    \end{center}

\end{document}